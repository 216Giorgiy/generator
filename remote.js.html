<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/actions/remote.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/actions/remote.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var fs = require('fs');
var path = require('path');
var _ = require('lodash');
var fileUtils = require('file-utils');
var rimraf = require('rimraf');

var noop = _.noop;

/**
 * @mixin
 * @alias actions/remote
 */
var remote = module.exports;

/**
 * Remotely fetch a package from github (or an archive), store this into a _cache
 * folder, and provide a "remote" object as a facade API to ourself (part of
 * genrator API, copy, template, directory). It's possible to remove local cache,
 * and force a new remote fetch of the package.
 *
 * ### Examples:
 *
 *     this.remote('user', 'repo', function(err, remote) {
 *       remote.copy('.', 'vendors/user-repo');
 *     });
 *
 *     this.remote('user', 'repo', 'branch', function(err, remote) {
 *       remote.copy('.', 'vendors/user-repo');
 *     });
 *
 *     this.remote('http://foo.com/bar.zip', function(err, remote) {
 *       remote.copy('.', 'vendors/user-repo');
 *     });
 *
 * When fetching from Github
 * @param {String} username
 * @param {String} repo
 * @param {String} branch
 * @param {Function} cb
 * @param {Boolean} refresh
 *
 * @also
 * When fetching an archive
 * @param {String} url
 * @param {Function} cb
 * @param {Boolean} refresh
 */

remote.remote = function () {
  var username;
  var repo;
  var branch;
  var cb;
  var refresh;
  var url;
  var cache;

  if (arguments.length &lt;= 3 &amp;&amp; typeof arguments[2] !== 'function') {
    url = arguments[0];
    cb = arguments[1];
    refresh = arguments[2];
    cache = path.join(this.cacheRoot(), _.slugify(url));
  } else {
    username = arguments[0];
    repo = arguments[1];
    branch = arguments[2];
    cb = arguments[3];
    refresh = arguments[4];

    if (!cb) {
      cb = branch;
      branch = 'master';
    }

    cache = path.join(this.cacheRoot(), username, repo, branch);
    url = 'http://github.com/' + [username, repo, 'archive', branch].join('/') + '.tar.gz';
  }

  var self = this;

  var done = function (err) {
    if (err) {
      return cb(err);
    }

    self.remoteDir(cache, cb);
  };

  fs.stat(cache, function (err) {
    // already cached
    if (!err) {
      // no refresh, so we can use this cache
      if (!refresh) {
        return done();
      }

      // otherwise, we need to remove it, to fetch it again
      rimraf(cache, function (err) {
        if (err) {
          return cb(err);
        }
        self.extract(url, cache, done);
      });

    } else {
      self.extract(url, cache, done);
    }
  });

  return this;
};

/**
 * Retrieve a stored directory and use as a remote reference. This is handy if
 * you have files you want to move that may have been downloaded differently to
 * using `this.remove()` (eg such as `node_modules` installed via `package.json`)
 *
 * ### Examples:
 *
 *     this.remote('foo/bar', function(err, remote) {
 *       remote.copy('.', 'vendors/user-repo');
 *     });
 *
 * @param {String} cache
 */
remote.remoteDir = function (cache, cb) {
  var self = this;
  var files = this.expandFiles('**', { cwd: cache, dot: true });

  var remote = {};
  remote.cachePath = cache;

  // simple proxy to `.copy(source, destination)`
  remote.copy = function copy(source, destination) {
    source = path.join(cache, source);
    self.copy(source, destination);
    return this;
  };

  // simple proxy to `.bulkCopy(source, destination)`
  remote.bulkCopy = function copy(source, destination) {
    source = path.join(cache, source);
    self.bulkCopy(source, destination);
    return this;
  };

  // same as `.template(source, destination, data)`
  remote.template = function template(source, destination, data) {
    data = data || self;
    destination = destination || source;
    source = path.join(cache, source);

    var body = self.engine(self.read(source), data);
    self.write(destination, body);
  };

  // same as `.template(source, destination)`
  remote.directory = function directory(source, destination) {
    var root = self.sourceRoot();
    self.sourceRoot(cache);
    self.directory(source, destination);
    self.sourceRoot(root);
  };

  // simple proxy to `.bulkDirectory(source, destination)`
  remote.bulkDirectory = function directory(source, destination) {
    var root = self.sourceRoot();
    self.sourceRoot(cache);
    self.bulkDirectory(source, destination);
    self.sourceRoot(root);
  };

  var fileLogger = { write: noop, warn: noop };

  // Set the file-utils environments
  // Set logger as a noop as logging is handled by the yeoman conflicter
  remote.src = fileUtils.createEnv({
    base: cache,
    dest: self.destinationRoot(),
    logger: fileLogger
  });
  remote.dest = fileUtils.createEnv({
    base: self.destinationRoot(),
    dest: cache,
    logger: fileLogger
  });

  remote.dest.registerValidationFilter('collision', self.getCollisionFilter());
  remote.src.registerValidationFilter('collision', self.getCollisionFilter());

  cb(null, remote, files);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="assert.html">test/assert</a></li><li><a href="helpers.html">test/helpers</a></li><li><a href="module-yeoman-generator.html">yeoman-generator</a></li></ul><h3>Classes</h3><ul><li><a href="Base.html">Base</a></li><li><a href="Environment.html">Environment</a></li><li><a href="NamedBase.html">NamedBase</a></li><li><a href="RunContext.html">RunContext</a></li><li><a href="Storage.html">Storage</a></li><li><a href="TerminalAdapter.html">TerminalAdapter</a></li></ul><h3>Mixins</h3><ul><li><a href="actions.html">actions/actions</a></li><li><a href="fetch.html">actions/fetch</a></li><li><a href="file.html">actions/file</a></li><li><a href="help.html">actions/help</a></li><li><a href="install.html">actions/install</a></li><li><a href="invoke.html">actions/invoke</a></li><li><a href="remote.html">actions/remote</a></li><li><a href="spawn_command.html">actions/spawn_command</a></li><li><a href="string.html">actions/string</a></li><li><a href="user.html">actions/user</a></li><li><a href="wiring.html">actions/wiring</a></li><li><a href="resolver.html">env/resolver</a></li><li><a href="common.html">util/common</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha8</a> on Sat Sep 13 2014 22:25:43 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
